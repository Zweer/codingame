The puzzle asks us to find the location of bombs in a rectangular building, represented as a grid of windows. We start at a given window `(X0, Y0)` and have a limited number of jumps `N`. Before each jump, we receive a direction (e.g., 'U' for Up, 'R' for Right, 'UR' for Up-Right) indicating where the bombs are relative to our current position. Our goal is to program Batman's device to output the coordinates of the next window to jump to, finding the bombs "as soon as possible".

**Strategy: Binary Search (Bisection Method) in 2D**

This problem is a classic application of binary search. Since we are given the direction of the bombs, we can progressively narrow down the possible area where the bombs are located.

1.  **Initialize Search Space:**
    We start by defining the entire building as our initial search space.
    *   `minX = 0`, `maxX = W - 1` (for horizontal coordinates)
    *   `minY = 0`, `maxY = H - 1` (for vertical coordinates)
    Our `currentX` and `currentY` initially are `X0` and `Y0`.

2.  **Process Direction Input:**
    In each turn, we receive `bombDir`. This string tells us if the bomb's `X` coordinate is less than (`L`) or greater than (`R`) our `currentX`, and if its `Y` coordinate is less than (`U`) or greater than (`D`) our `currentY`.

    *   If `bombDir` contains 'U' (Up): The bomb is at a `Y` coordinate smaller than `currentY`. This means the new maximum possible `Y` coordinate for the bomb is `currentY - 1`. So, we update `maxY = currentY - 1`.
    *   If `bombDir` contains 'D' (Down): The bomb is at a `Y` coordinate larger than `currentY`. This means the new minimum possible `Y` coordinate for the bomb is `currentY + 1`. So, we update `minY = currentY + 1`.
    *   If `bombDir` contains 'L' (Left): The bomb is at an `X` coordinate smaller than `currentX`. This means the new maximum possible `X` coordinate for the bomb is `currentX - 1`. So, we update `maxX = currentX - 1`.
    *   If `bombDir` contains 'R' (Right): The bomb is at an `X` coordinate larger than `currentX`. This means the new minimum possible `X` coordinate for the bomb is `currentX + 1`. So, we update `minX = currentX + 1`.

    It's crucial to use independent `if` statements for each direction (U, D, L, R) because a direction like `UR` implies both 'U' and 'R' conditions apply simultaneously.

3.  **Calculate Next Jump:**
    After narrowing down the search space using the `bombDir`, the most efficient way to find the target is to jump to the middle of the remaining possible area. This is the core of binary search: it halves the search space in each step.
    *   `nextX = Math.floor((minX + maxX) / 2)`
    *   `nextY = Math.floor((minY + maxY) / 2)`
    We use `Math.floor` to ensure integer coordinates. This choice (floor vs. ceil for midpoint) might vary slightly between implementations but consistently converges.

4.  **Update Current Position and Output:**
    The calculated `(nextX, nextY)` becomes our new `currentX, currentY` for the next turn. We then print these coordinates to standard output. The game system handles the loop termination when the bombs are found.

This approach guarantees that we will find the bombs in `O(log(W) + log(H))` jumps, which is very efficient and well within the `N=100` jump limit for `W, H` up to 10000.

**Example Trace (with correct binary search logic):**

Let's re-trace the first step of the provided example:
*   `W=10`, `H=10`
*   `X0=2`, `Y0=5` (Batman's starting position)

Initial state:
*   `currentX = 2`, `currentY = 5`
*   `minX = 0`, `maxX = 9`
*   `minY = 0`, `maxY = 9`

**Turn 1:**
Input `BOMB_DIR = "UR"`

1.  **Update Boundaries:**
    *   `bombDir.includes('U')` is true: `maxY = currentY - 1 = 5 - 1 = 4`
    *   `bombDir.includes('D')` is false.
    *   `bombDir.includes('L')` is false.
    *   `bombDir.includes('R')` is true: `minX = currentX + 1 = 2 + 1 = 3`

2.  **New Search Space:**
    *   `minX = 3`, `maxX = 9`
    *   `minY = 0`, `maxY = 4`

3.  **Calculate Next Jump:**
    *   `nextX = Math.floor((3 + 9) / 2) = Math.floor(12 / 2) = 6`
    *   `nextY = Math.floor((0 + 4) / 2) = Math.floor(4 / 2) = 2`

4.  **Output:** `6 2` (This differs from the example's `5 4`, but is the optimal binary search jump).

The provided example outputs `5 4`. CodinGame examples sometimes show *a* valid solution path rather than *the* unique optimal path generated by a specific algorithm. The "as soon as possible" goal, along with the constraints, strongly implies a binary search solution.